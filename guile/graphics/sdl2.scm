;; autogenerated file from documentation sdl.org file via emacs

(define-module (graphics sdl2)
  #:export (*sdl-init-timer*
	    *sdl-init-audio*
	    *sdl-init-video*
	    *sdl-init-joystick*
	    *sdl-init-haptic*
	    *sdl-init-gamecontroller*
	    *sdl-init-events*
	    *sdl-init-sensor*
	    *sdl-init-parachute*
	    *sdl-init-everything*
	    sdl-init
	    sdl-quit
	    
sdl-create-window
create-window
sdl-get-window-surface
sdl-free-surface
sdl-load-bmp-rw
sdl-rw-from-file
sdl-load-bmp
sdl-show-cursor
load-texture
img-quit
sdl-destroy-window

sdl-lock-surface
sdl-unlock-surface


sdl-get-window-size
sdl-get-renderer-output-size

sanity-check-hack ;; <<<<< 

sdl-create-texture-from-surface
sdl-destroy-texture
sdl-destroy-renderer
sdl-create-rgb-surface

sdl-get-pixelformat-name
create-rgb24-surface
create-argb32-surface

sdl-map-rgb
sdl-fill-rect
sdl-update-window-surface
sdl-convert-surface
sdl-blit-surface
sdl-render-clear
sdl-render-copy
sdl-render-present
sdl-render-draw-line
sdl-render-draw-rect
sdl-render-fill-rect
sdl-render-draw-point

sdl-poll-event

*sdl-quit*
*sdl-keydown*
*sdl-keyup*
*sdl-mousemotion*
*sdl-window-event*
*sdl-scancode-unknown* 
*sdl-scancode-a* 
*sdl-scancode-b* 
*sdl-scancode-c* 
*sdl-scancode-d* 
*sdl-scancode-e* 
*sdl-scancode-f* 
*sdl-scancode-g* 
*sdl-scancode-h* 
*sdl-scancode-i* 
*sdl-scancode-j* 
*sdl-scancode-k* 
*sdl-scancode-l* 
*sdl-scancode-m* 
*sdl-scancode-n* 
*sdl-scancode-o* 
*sdl-scancode-p* 
*sdl-scancode-q* 
*sdl-scancode-r* 
*sdl-scancode-s* 
*sdl-scancode-t* 
*sdl-scancode-u* 
*sdl-scancode-v* 
*sdl-scancode-w* 
*sdl-scancode-x* 
*sdl-scancode-y* 
*sdl-scancode-z* 
*sdl-scancode-1* 
*sdl-scancode-2* 
*sdl-scancode-3* 
*sdl-scancode-4* 
*sdl-scancode-5* 
*sdl-scancode-6* 
*sdl-scancode-7* 
*sdl-scancode-8* 
*sdl-scancode-9* 
*sdl-scancode-0* 
*sdl-scancode-return* 
*sdl-scancode-escape* 
*sdl-scancode-backspace* 
*sdl-scancode-tab* 
*sdl-scancode-space* 
*sdl-scancode-minus* 
*sdl-scancode-equals* 
*sdl-scancode-leftbracket* 
*sdl-scancode-rightbracket* 
*sdl-scancode-backslash* 
*sdl-scancode-nonushash* 
*sdl-scancode-semicolon* 
*sdl-scancode-apostrophe* 
*sdl-scancode-grave* 
*sdl-scancode-comma* 
*sdl-scancode-period* 
*sdl-scancode-slash* 
*sdl-scancode-capslock* 
*sdl-scancode-f1* 
*sdl-scancode-f2* 
*sdl-scancode-f3* 
*sdl-scancode-f4* 
*sdl-scancode-f5* 
*sdl-scancode-f6* 
*sdl-scancode-f7* 
*sdl-scancode-f8* 
*sdl-scancode-f9* 
*sdl-scancode-f10* 
*sdl-scancode-f11* 
*sdl-scancode-f12* 
*sdl-scancode-printscreen* 
*sdl-scancode-scrolllock* 
*sdl-scancode-pause* 
*sdl-scancode-insert* 
*sdl-scancode-home* 
*sdl-scancode-pageup* 
*sdl-scancode-delete* 
*sdl-scancode-end* 
*sdl-scancode-pagedown* 
*sdl-scancode-right* 
*sdl-scancode-left* 
*sdl-scancode-down* 
*sdl-scancode-up* 
*sdl-scancode-numlockclear* 
*sdl-scancode-kp-divide* 
*sdl-scancode-kp-multiply* 
*sdl-scancode-kp-minus* 
*sdl-scancode-kp-plus* 
*sdl-scancode-kp-enter* 
*sdl-scancode-kp-1* 
*sdl-scancode-kp-2* 
*sdl-scancode-kp-3* 
*sdl-scancode-kp-4* 
*sdl-scancode-kp-5* 
*sdl-scancode-kp-6* 
*sdl-scancode-kp-7* 
*sdl-scancode-kp-8* 
*sdl-scancode-kp-9* 
*sdl-scancode-kp-0* 
*sdl-scancode-kp-period* 
*sdl-scancode-nonusbackslash* 
*sdl-scancode-application* 
*sdl-scancode-power* 
*sdl-scancode-kp-equals* 
*sdl-scancode-f13* 
*sdl-scancode-f14* 
*sdl-scancode-f15* 
*sdl-scancode-f16* 
*sdl-scancode-f17* 
*sdl-scancode-f18* 
*sdl-scancode-f19* 
*sdl-scancode-f20* 
*sdl-scancode-f21* 
*sdl-scancode-f22* 
*sdl-scancode-f23* 
*sdl-scancode-f24* 
*sdl-scancode-execute* 
*sdl-scancode-help* 
*sdl-scancode-menu* 
*sdl-scancode-select* 
*sdl-scancode-stop* 
*sdl-scancode-again* 
*sdl-scancode-undo* 
*sdl-scancode-cut* 
*sdl-scancode-copy* 
*sdl-scancode-paste* 
*sdl-scancode-find* 
*sdl-scancode-mute* 
*sdl-scancode-volumeup* 
*sdl-scancode-volumedown* 
*sdl-scancode-lockingcapslock* 
*sdl-scancode-lockingnumlock* 
*sdl-scancode-lockingscrolllock* 
*sdl-scancode-kp-comma* 
*sdl-scancode-kp-equalsas400* 
*sdl-scancode-international1* 
*sdl-scancode-international2* 
*sdl-scancode-international3* 
*sdl-scancode-international4* 
*sdl-scancode-international5* 
*sdl-scancode-international6* 
*sdl-scancode-international7* 
*sdl-scancode-international8* 
*sdl-scancode-international9* 
*sdl-scancode-lang1* 
*sdl-scancode-lang2* 
*sdl-scancode-lang3* 
*sdl-scancode-lang4* 
*sdl-scancode-lang5* 
*sdl-scancode-lang6* 
*sdl-scancode-lang7* 
*sdl-scancode-lang8* 
*sdl-scancode-lang9* 
*sdl-scancode-alterase* 
*sdl-scancode-sysreq* 
*sdl-scancode-cancel* 
*sdl-scancode-clear* 
*sdl-scancode-prior* 
*sdl-scancode-return2* 
*sdl-scancode-separator* 
*sdl-scancode-out* 
*sdl-scancode-oper* 
*sdl-scancode-clearagain* 
*sdl-scancode-crsel* 
*sdl-scancode-exsel* 
*sdl-scancode-kp-00* 
*sdl-scancode-kp-000* 
*sdl-scancode-thousandsseparator* 
*sdl-scancode-decimalseparator* 
*sdl-scancode-currencyunit* 
*sdl-scancode-currencysubunit* 
*sdl-scancode-kp-leftparen* 
*sdl-scancode-kp-rightparen* 
*sdl-scancode-kp-leftbrace* 
*sdl-scancode-kp-rightbrace* 
*sdl-scancode-kp-tab* 
*sdl-scancode-kp-backspace* 
*sdl-scancode-kp-a* 
*sdl-scancode-kp-b* 
*sdl-scancode-kp-c* 
*sdl-scancode-kp-d* 
*sdl-scancode-kp-e* 
*sdl-scancode-kp-f* 
*sdl-scancode-kp-xor* 
*sdl-scancode-kp-power* 
*sdl-scancode-kp-percent* 
*sdl-scancode-kp-less* 
*sdl-scancode-kp-greater* 
*sdl-scancode-kp-ampersand* 
*sdl-scancode-kp-dblampersand* 
*sdl-scancode-kp-verticalbar* 
*sdl-scancode-kp-dblverticalbar* 
*sdl-scancode-kp-colon* 
*sdl-scancode-kp-hash* 
*sdl-scancode-kp-space* 
*sdl-scancode-kp-at* 
*sdl-scancode-kp-exclam* 
*sdl-scancode-kp-memstore* 
*sdl-scancode-kp-memrecall* 
*sdl-scancode-kp-memclear* 
*sdl-scancode-kp-memadd* 
*sdl-scancode-kp-memsubtract* 
*sdl-scancode-kp-memmultiply* 
*sdl-scancode-kp-memdivide* 
*sdl-scancode-kp-plusminus* 
*sdl-scancode-kp-clear* 
*sdl-scancode-kp-clearentry* 
*sdl-scancode-kp-binary* 
*sdl-scancode-kp-octal* 
*sdl-scancode-kp-decimal* 
*sdl-scancode-kp-hexadecimal* 
*sdl-scancode-lctrl* 
*sdl-scancode-lshift* 
*sdl-scancode-lalt* 
*sdl-scancode-lgui* 
*sdl-scancode-rctrl* 
*sdl-scancode-rshift* 
*sdl-scancode-ralt* 
*sdl-scancode-rgui* 
*sdl-scancode-mode* 
*sdl-scancode-audionext* 
*sdl-scancode-audioprev* 
*sdl-scancode-audiostop* 
*sdl-scancode-audioplay* 
*sdl-scancode-audiomute* 
*sdl-scancode-mediaselect* 
*sdl-scancode-www* 
*sdl-scancode-mail* 
*sdl-scancode-calculator* 
*sdl-scancode-computer* 
*sdl-scancode-ac-search* 
*sdl-scancode-ac-home* 
*sdl-scancode-ac-back* 
*sdl-scancode-ac-forward* 
*sdl-scancode-ac-stop* 
*sdl-scancode-ac-refresh* 
*sdl-scancode-ac-bookmarks* 
*sdl-scancode-brightnessdown* 
*sdl-scancode-brightnessup* 
*sdl-scancode-displayswitch* 
*sdl-scancode-kbdillumtoggle* 
*sdl-scancode-kbdillumdown* 
*sdl-scancode-kbdillumup* 
*sdl-scancode-eject* 
*sdl-scancode-sleep* 
*sdl-scancode-app1* 
*sdl-scancode-app2* 
*sdl-scancode-audiorewind* 
*sdl-scancode-audiofastforward* 
*sdl-scancode-softleft* 
*sdl-scancode-softright* 
*sdl-scancode-call* 
*sdl-scancode-endcall* 
*sdl-num-scancodes* 

*sdl-window-event-none* 
*sdl-window-event-shown* 
*sdl-window-event-hidden* 
*sdl-window-event-exposed* 
*sdl-window-event-moved* 
*sdl-window-event-resized* 
*sdl-window-event-changed* 
*sdl-window-event-minimized* 
*sdl-window-event-maximized* 
*sdl-window-event-restored* 
*sdl-window-event-enter* 
*sdl-window-event-leave* 
*sdl-window-event-focus-gained* 
*sdl-window-event-focus-lost* 
*sdl-window-event-close* 
*sdl-window-event-take-focus* 
*sdl-window-event-hit-test* 
*sdl-window-event-icc-prof-changed* 
*sdl-window-event-display-changed* 



;; libpixelformat.so 
;;pixelformat 
pixelformat2  
output-check
applyStretchedImage
size-int
sdl-upper-blit-scaled
  
*sdl-image-init-jpg*
*sdl-image-init-png*  
*sdl-image-init-tif*  
*sdl-image-init-webp* 
*sdl-image-init-jxl*  
*sdl-image-init-avif* 

%img-init
%img-load
image-load  
image-init
%sdl-create-renderer

surface-pixelformat-format
surface-pixelformat
surface-pixels  
surface-width
surface-height
surface-pitch

sdl-set-render-draw-color
show-rect

*sdl-renderer-software* 
*sdl-renderer-accelerated* 
*sdl-renderer-present-vsync* 
*sdl-renderer-target-texture* 
  
create-renderer
  
ttf-init
ttf-quit
ttf-render-text-solid
ttf-render-utf8-blended-wrapped
ttf-open-font
ttf-close-font

;; some cairo stuff - not sure it works yet

*cairo-format-rgb24* ;; ??
*cairo-format-argb32*


cairo-format-stride-for-width
cairo-image-surface-create

cairo-image-surface-create-for-data
cairo-rectangle
cairo-set-source-rgb
cairo-set-source-rgba
cairo-create
cairo-fill
cairo-surface-flush

cairo-set-line-width
cairo-stroke
cairo-arc
cairo-line-to
cairo-destroy
cairo-version-string
))

(use-modules (system foreign-library)) ;; probably only need system foreign
(use-modules (system foreign))

;; guile #x means HEX value follows #xFF is 255 decimal
  
(define *sdl-init-timer*             #x00000001)
(define *sdl-init-audio*             #x00000010)
(define *sdl-init-video*             #x00000020)
(define *sdl-init-joystick*          #x00000200)
(define *sdl-init-haptic*            #x00001000)
(define *sdl-init-gamecontroller*    #x00002000)
(define *sdl-init-events*            #x00004000)
(define *sdl-init-sensor*            #x00008000)
(define *sdl-init-parachute*         #x00100000)

;; guile logior is logical inclusive or
  
(define *init-everything*  (logior *sdl-init-timer*
				   *sdl-init-audio*
				   *sdl-init-video*
				   *sdl-init-events*
				   *sdl-init-joystick*
				   *sdl-init-haptic*
				   *sdl-init-gamecontroller*
				   *sdl-init-sensor*))

(define sdl-init
(foreign-library-function "libSDL2" "SDL_Init"
                            #:return-type int
                            #:arg-types (list uint32)))

(define sdl-quit
  (foreign-library-function "libSDL2" "SDL_Quit"
                            #:return-type void
                            #:arg-types (list)))

(define *sdl-window-fullscreen* #x00000001)
(define *sdl-window-opengl* #x00000002)
(define *sdl-window-shown* #x00000004)
(define *sdl-window-hidden* #x00000008)
(define *sdl-window-borderless* #x00000010)
(define *sdl-window-resizeable* #x00000020)
(define *sdl-window-minimized* #x00000040)
(define *sdl-window-maximized* #x00000080)
(define *sdl-window-mouse-grabbed* #x000000100)
(define *sdl-window-input-focus* #x000000200)
(define *sdl-window-mouse-focus* #x000000400)
(define *sdl-window-fullscreen-desktop* (logior *sdl-window-fullscreen* #x0001000))
(define *sdl-window-foreign* #x000000800)
(define *sdl-window-allow-highdpi* #x0000002000)
(define *sdl-window-mouse-capture* #x0000004000)
(define *sdl-window-always-on-top* #x0000008000)
(define *sdl-window-skip-taskbar* #x00000010000)
(define *sdl-window-utility* #x00000020000)
(define *sdl-window-tooltip* #x00000040000)
(define *sdl-window-popup-menu* #x00000080000)
(define *sdl-window-keyboard-grabbed* #x00100000)
(define *sdl-window-vulkan* #x10000000)
(define *sdl-window-metal*  #x20000000)
(define *sdl-window-input-grabbed*  *sdl-window-mouse-grabbed*)

;; how represent a char* in guile ffi ??
;; #:return-type '*  means a pointer   :: a quoted star symbol '*  , not scheme * multiply symbol
;; #:arg-types (list 
(define sdl-create-window 
  (foreign-library-function "libSDL2" "SDL_CreateWindow"
                            #:return-type '*
                            #:arg-types (list '* int int int int int)))


;; guile string -> char* use : string->pointer :
;; example
;; (string->pointer "my window")
;; will return an appropriate ? null terminated ? char* ?? for the guile string "my window"

;; convenience middle of my screen 1920 x 1080 default resolution
(define (create-window title width height)
  (let ((x (floor (/ (- 1920 width) 2)))
	(y (floor (/ (- 1080 height) 2)))
	(flags (logior ;;*sdl-window-fullscreen-desktop*
		        *sdl-window-resizeable*
		        *sdl-window-allow-highdpi*
			*sdl-window-always-on-top*
			;;*sdl-window-fullscreen*
		       ;;*sdl-window-borderless*
		       *sdl-window-shown*)))
    (sdl-create-window (string->pointer title) x y width height flags)))


(define (sdl-get-window-size win wid hgt)
  "sdl-get-window-size win* &wid &hgt"
  (lowlevel-sdl-get-window-size win wid hgt))

(define lowlevel-sdl-get-window-size
  (foreign-library-function "libSDL2" "SDL_GetWindowSize"
                            #:return-type void
                            #:arg-types (list '* '* '* )))

(define (sdl-get-renderer-output-size render wid hgt)
  "sdl-get-renderer-output-size render &wid &hgt"
  (lowlevel-sdl-get-renderer-output-size render wid hgt)) 

(define lowlevel-sdl-get-renderer-output-size
  (foreign-library-function "libSDL2" "SDL_GetRendererOutputSize"
                            #:return-type void
                            #:arg-types (list '* '* '* )))



;; gScreenSurface = SDL_GetWindowSurface( gWindow );
(define sdl-get-window-surface 
  (foreign-library-function "libSDL2" "SDL_GetWindowSurface"
                            #:return-type '*
                            #:arg-types (list '* )))

;; void SDL_FreeSurface(SDL_Surface * surface)
(define sdl-free-surface
  (foreign-library-function "libSDL2" "SDL_FreeSurface"
                            #:return-type void
                            #:arg-types (list '*)))



;;SDL_Surface* SDL_LoadBMP_RW(SDL_RWops * src, int freesrc);
(define sdl-load-bmp-rw
  (foreign-library-function "libSDL2" "SDL_LoadBMP_RW"
                            #:return-type '*
                            #:arg-types (list '* int)))


;; SDL_RWops* SDL_RWFromFile(const char *file, const char *mode);
(define sdl-rw-from-file
  ;; " guile ffi need string->pointer "
  (foreign-library-function "libSDL2" "SDL_RWFromFile"
                            #:return-type '*
                            #:arg-types (list '* '*)))


;; #define SDL_LoadBMP(file)   SDL_LoadBMP_RW(SDL_RWFromFile(file, "rb"), 1)
(define (sdl-load-bmp filename)
  "SDL_LoadBMP is a macro in C land
 becomes two required routines
 SDL_RWFromFile(file, \"rb\")
 SDL_LoadBMP_RW
 "
  (sdl-load-bmp-rw (sdl-rw-from-file (string->pointer filename) (string->pointer "rb")) 1))


;; int SDL_ShowCursor(int toggle);
(define sdl-show-cursor
  (foreign-library-function "libSDL2" "SDL_ShowCursor"
                            #:return-type int
                            #:arg-types (list int)))




#|
SDL_Texture* loadTexture( char *path , SDL_Renderer *render)
{
    //The final texture
    SDL_Texture* newTexture = NULL;

    //Load image at specified path
    SDL_Surface* loadedSurface = IMG_Load( path );
    if( loadedSurface == NULL )
    {
        printf( "Unable to load image %s! SDL_image Error: %s\n", path, IMG_GetError() );
    }
    else
    {
        //Create texture from surface pixels
        newTexture = SDL_CreateTextureFromSurface( render, loadedSurface );
        if( newTexture == NULL )
        {
            printf( "Unable to create texture from %s! SDL Error: %s\n", path, SDL_GetError() );
        }

        //Get rid of old loaded surface
        SDL_FreeSurface( loadedSurface );
    }

    return newTexture;
}
|#

(define (load-texture path render)
  (define loaded-surface (%img-load (string->pointer path)))
  (cond
   ((equal? loaded-surface %null-pointer)
    (format #t "unable to load image ~a ~%" path)
    %null-pointer)
   (#t (let ((new-texture (sdl-create-texture-from-surface render loaded-surface)))
	 (cond
	  ((equal? new-texture %null-pointer)
	   (format #t "unable to create texture from image ~a ~%" path)
	   %null-pointer)
	  (#t (sdl-free-surface loaded-surface)
	      new-texture))))))


(define img-quit
  (foreign-library-function "libSDL2_image" "IMG_Quit"
                            #:return-type void
                            #:arg-types (list )))



  


;; nm -D /usr/lib/x86_64-linux-gnu/libSDL2.so | grep SDL_LoadBMP
;; 000000000004c620 T SDL_LoadBMP_RW
;;
;; C macros strikes again - no such thing in shared library 
;; In procedure dlsym: Error resolving "SDL_LoadBMP": "/usr/lib/x86_64-linux-gnu/libSDL2.so: undefined symbol: SDL_LoadBMP"
;;  #define SDL_LoadBMP(file)   SDL_LoadBMP_RW(SDL_RWFromFile(file, "rb"), 1)
;;


;; usage
;;SDL_DestroyWindow( gWindow );
(define sdl-destroy-window
  (foreign-library-function "libSDL2" "SDL_DestroyWindow"
                            #:return-type void
                            #:arg-types (list '* )))


;;SDL_Texture * SDL_CreateTextureFromSurface(SDL_Renderer * renderer, SDL_Surface * surface);
(define sdl-create-texture-from-surface
  (foreign-library-function "libSDL2" "SDL_CreateTextureFromSurface"
                            #:return-type '*
                            #:arg-types (list '* '*)))


;;void SDL_DestroyTexture(SDL_Texture * texture);
(define sdl-destroy-texture
  (foreign-library-function "libSDL2" "SDL_DestroyTexture"
                            #:return-type void
                            #:arg-types (list '*)))



;;SDL_DestroyRenderer
;;void SDL_DestroyRenderer(SDL_Renderer * renderer);
(define sdl-destroy-renderer
  (foreign-library-function "libSDL2" "SDL_DestroyRenderer"
                            #:return-type void
                            #:arg-types (list '*)))





;; usage
;; int flags = 0; // flags unused should be set to 0 ??
;; 	  int width = SCREEN_WIDTH; // 640 pixels wide
;; 	  int height = SCREEN_HEIGHT; // 480 pixels high
;; 	  int depth = 32; // 32 bits - cairo only understands 32 bits
;; 	  SDL_Surface *sdlsurf = SDL_CreateRGBSurface (
;; 						       flags, width, height, depth,
;; 						       0x00FF0000, /* Rmask */
;; 						       0x0000FF00, /* Gmask */
;; 						       0x000000FF, /* Bmask */
;; 						       0); /* Amask */

;; SDL_Surface* SDL_CreateRGBSurface
;;     (Uint32 flags, int width, int height, int depth,               u i i i
;;      Uint32 Rmask, Uint32 Gmask, Uint32 Bmask, Uint32 Amask);      u u u u
(define sdl-create-rgb-surface  
  (foreign-library-function "libSDL2" "SDL_CreateRGBSurface"
                            #:return-type '*
                            #:arg-types (list uint32 int int int
					      uint32 uint32 uint32 uint32)))

;;
;; source : https://www.cairographics.org/SDL/
;;
;; SDL_Surface *sdlsurf = SDL_CreateRGBSurface (
;;     flags, width, height, 32,
;;     0x00FF0000, /* Rmask */
;;     0x0000FF00, /* Gmask */
;;     0x000000FF, /* Bmask */
;;     0); /* Amask */
;;
;; /* ... make sure sdlsurf is locked or doesn't need locking ... */
;;
;; cairo_surface_t *cairosurf = cairo_image_surface_create_for_data (
;;     sdlsurf->pixels,
;;     CAIRO_FORMAT_RGB24,
;;     sdlsurf->w,
;;     sdlsurf->h,
;;     sdlsurf->pitch);
;;
;; /* ... normal cairo calls ... */
(define (create-rgb24-surface width height)
  (let ((flags 0) ;;unused
	(depth 32) ;; only depth SDL and CAIRO agree on
	(rmask #x00FF0000) ;; red mask
	(gmask #x0000FF00) ;; green mask
	(bmask #x000000FF) ;; blue mask
	(amask #x0)) ;; alpha mask - unused	
    (sdl-create-rgb-surface flags width height depth rmask gmask bmask amask)))


(define (create-argb32-surface width height) ;; with alpha !
  (let ((flags 0) ;;unused
	(depth 32) ;; only depth SDL and CAIRO agree on
	(rmask #x00FF0000) ;; red mask
	(gmask #x0000FF00) ;; green mask
	(bmask #x000000FF) ;; blue mask
	(amask #xFF000000)) ;; alpha mask 
    (sdl-create-rgb-surface flags width height depth rmask gmask bmask amask)))




;; guile (use-modules (system foreign)) exposes typical C types uint8 uint32 etc..
;; assuming NULL is just 0
;; Uint32 SDL_MapRGB(const SDL_PixelFormat * format,  Uint8 r, Uint8 g, Uint8 b);
(define sdl-map-rgb
  (foreign-library-function "libSDL2" "SDL_MapRGB"
                            #:return-type uint32
                            #:arg-types (list '* uint8 uint8 uint8)))


;; int SDL_FillRect (SDL_Surface * dst, const SDL_Rect * rect, Uint32 color);
;; returns 0 on success
(define sdl-fill-rect
  (foreign-library-function "libSDL2" "SDL_FillRect"
			    #:return-type int
                            #:arg-types (list '* '* uint32)))


;; int SDL_UpdateWindowSurface(SDL_Window * window);
(define sdl-update-window-surface
  (foreign-library-function "libSDL2" "SDL_UpdateWindowSurface"
			    #:return-type int
                            #:arg-types (list '*)))


#|
https://lazyfoo.net/tutorials/SDL/05_optimized_surface_loading_and_soft_stretching/index.php

SDL_Surface* SDL_ConvertSurface
(SDL_Surface * src, const SDL_PixelFormat * fmt, Uint32 flags;)
|#
(define sdl-convert-surface
  (foreign-library-function "libSDL2" "SDL_ConvertSurface"
			    #:return-type '*
                            #:arg-types (list '* '* uint32)))






;; ======================== cairo stuff ========================================

#|
cairo_surface_t *cairosurf = cairo_image_surface_create_for_data (
									    (unsigned char*)sdlsurf->pixels,
									    CAIRO_FORMAT_RGB24,
									    sdlsurf->w,
									    sdlsurf->h,
									    sdlsurf->pitch);
	  

#define SDL_BlitSurface SDL_UpperBlit
int SDL_UpperBlit
    (SDL_Surface * src, const SDL_Rect * srcrect,
     SDL_Surface * dst, SDL_Rect * dstrect);

|#
(define sdl-blit-surface 
  (foreign-library-function "libSDL2" "SDL_UpperBlit"
			    #:return-type int
                            #:arg-types (list '* '* '* '*)))


;; render-clear
;; int SDL_RenderClear(SDL_Renderer * renderer);
(define sdl-render-clear
  (foreign-library-function "libSDL2" "SDL_RenderClear"
			    #:return-type int
                            #:arg-types (list '*)))

;; int SDL_RenderCopy(SDL_Renderer * renderer,
;;                    SDL_Texture * texture,
;;                    const SDL_Rect * srcrect,
;;                    const SDL_Rect * dstrect);
(define sdl-render-copy
  (foreign-library-function "libSDL2" "SDL_RenderCopy"
			    #:return-type int
                            #:arg-types (list '* '* '* '*)))

;; void SDL_RenderPresent(SDL_Renderer * renderer);
(define sdl-render-present
  (foreign-library-function "libSDL2" "SDL_RenderPresent"
			    #:return-type int
                            #:arg-types (list '*)))


;; int SDL_RenderDrawLine(SDL_Renderer * renderer,
;;                        int x1, int y1, int x2, int y2);
(define sdl-render-draw-line
  (foreign-library-function "libSDL2" "SDL_RenderDrawLine"
			    #:return-type int
                            #:arg-types (list '* int int int int)))

;; int SDL_RenderDrawRect(SDL_Renderer * renderer,   const SDL_Rect * rect);
(define sdl-render-draw-rect
  (foreign-library-function "libSDL2" "SDL_RenderDrawRect"
			    #:return-type int
                            #:arg-types (list '* '*)))

;; int SDL_RenderFillRect(SDL_Renderer * renderer,
;;                        const SDL_Rect * rect);
(define sdl-render-fill-rect
  (foreign-library-function "libSDL2" "SDL_RenderFillRect"
			    #:return-type int
                            #:arg-types (list '* '*)))


;; int SDL_RenderDrawPoint(SDL_Renderer * renderer,
;;                         int x, int y);
(define sdl-render-draw-point
  (foreign-library-function "libSDL2" "SDL_RenderDrawPoint"
			    #:return-type int
                            #:arg-types (list '* int int)))


;; int TTF_Init(void);
(define ttf-init
  (foreign-library-function "libSDL2_ttf" "TTF_Init"
			    #:return-type int
                            #:arg-types (list)))

;; void TTF_Quit(void);
(define ttf-quit
  (foreign-library-function "libSDL2_ttf" "TTF_Quit"
			    #:return-type void
                            #:arg-types (list)))

;; SDL_Surface * TTF_RenderText_Solid(TTF_Font *font,   const char *text, SDL_Color fg);
;; what do if structure was just as a parameter , not a pointer , how cope if structure bigger than 64bit ?
;; does scheme do the integer conversion implicitly then ?
(define ttf-render-text-solid
  (foreign-library-function "libSDL2_ttf" "TTF_RenderText_Solid"
			    #:return-type '*
                            #:arg-types (list '* '* uint32)))



;; typedef struct SDL_Color
;; {
;;     Uint8 r;
;;     Uint8 g;
;;     Uint8 b;
;;     Uint8 a;
;; } SDL_Color;
;; SDL_Color is just an unsigned 32 bit uint32  (4 * 8 = 32)

;;SDL_Surface * TTF_RenderUTF8_Blended_Wrapped(TTF_Font *font, const char *text, SDL_Color fg, Uint32 wrapLength);
(define ttf-render-utf8-blended-wrapped
  (foreign-library-function "libSDL2_ttf" "TTF_RenderUTF8_Blended_Wrapped"
			    #:return-type '*
                            #:arg-types (list '* '* uint32 uint32)))



;; gFont = TTF_OpenFont( "16_true_type_fonts/lazy.ttf", 28 );
;; TTF_Font * TTF_OpenFont(const char *file, int ptsize);
(define ttf-open-font
  (foreign-library-function "libSDL2_ttf" "TTF_OpenFont"
			    #:return-type '*
                            #:arg-types (list '* int)))

;; void TTF_CloseFont(TTF_Font *font);
(define ttf-close-font
  (foreign-library-function "libSDL2_ttf" "TTF_CloseFont"
			    #:return-type void
                            #:arg-types (list '*)))





;; from reference/cairo-001/demo
;; /usr/include/SDL2/SDL_pixels.h 
(define *cairo-format-rgb24* 1)
(define *cairo-format-argb32* 0)


;;int cairo_format_stride_for_width (cairo_format_t format,    int width);
;; cairo_format_t enum = int
(define cairo-format-stride-for-width
  (foreign-library-function "libcairo" "cairo_format_stride_for_width"
                            #:return-type int
                            #:arg-types (list int int)))


;; cairo_surface_t *
;; cairo_image_surface_create (cairo_format_t format, ;; enum = int
;;                             int width,
;;                             int height);
(define cairo-image-surface-create
  (foreign-library-function "libcairo" "cairo_image_surface_create"
                            #:return-type '*
                            #:arg-types (list int int int)))


;; cairo_surface_t *
;; cairo_image_surface_create_for_data (unsigned char *data,
;;                                      cairo_format_t format,  ;; enum = int
;;                                      int width,
;;                                      int height,
;;                                      int stride);
(define cairo-image-surface-create-for-data
  (foreign-library-function "libcairo" "cairo_image_surface_create_for_data"
                            #:return-type '*
                            #:arg-types (list '* int int int int)))

;; void
;; cairo_rectangle (cairo_t *cr,
;;                  double x,
;;                  double y,
;;                  double width,
;;                  double height);
(define cairo-rectangle
  (foreign-library-function "libcairo" "cairo_rectangle"
                            #:return-type void
                            #:arg-types (list '* double double double double)))



(define cairo-set-source-rgb
  (foreign-library-function "libcairo" "cairo_set_source_rgb"
                            #:return-type void
                            #:arg-types (list '* double double double)))





;; void
;; cairo_set_source_rgba (cairo_t *cr,
;;                        double red,
;;                        double green,
;;                        double blue,
;;                        double alpha);
(define cairo-set-source-rgba
  (foreign-library-function "libcairo" "cairo_set_source_rgba"
                            #:return-type void
                            #:arg-types (list '* double double double double)))




;; cairo_t *cairo_create( cairo_surface_t *)
;; cairo_t is cairo context
;; cairo_surface_t is a surface compatible with cairo 24 bit 
(define cairo-create
  (foreign-library-function "libcairo" "cairo_create"
                            #:return-type '*
                            #:arg-types (list '*)))


(define cairo-fill
  (foreign-library-function "libcairo" "cairo_fill"
                            #:return-type void
                            #:arg-types (list '*)))


;;void cairo_set_line_width (cairo_t *cr, double width);
(define lowlevel-cairo-set-line-width
  (foreign-library-function "libcairo" "cairo_set_line_width"
                            #:return-type void
                            #:arg-types (list '* double)))

(define (cairo-set-line-width cr width)
  "cairo_set_line_width ()
void
cairo_set_line_width (cairo_t *cr,
                      double width);
Sets the current line width within the cairo context. The line width value specifies the diameter of a pen that is circular in user space, (though device-space pen may be an ellipse in general due to scaling/shear/rotation of the CTM).

Note: When the description above refers to user space and CTM it refers to the user space and CTM in effect at the time of the stroking operation, not the user space and CTM in effect at the time of the call to cairo_set_line_width(). The simplest usage makes both of these spaces identical. That is, if there is no change to the CTM between a call to cairo_set_line_width() and the stroking operation, then one can just pass user-space values to cairo_set_line_width() and ignore this note.

As with the other stroke parameters, the current line width is examined by cairo_stroke(), and cairo_stroke_extents(), but does not have any effect during path construction.

The default line width value is 2.0.

Parameters
cr

a cairo_t

 
width

a line width

 
Since: 1.0"
  (lowlevel-cairo-set-line-width cr width))


(define (cairo-stroke cr)
  "cairo_stroke ()
void cairo_stroke (cairo_t *cr);
A drawing operator that strokes the current path according to the current line width, line join, line cap, and dash settings. After cairo_stroke(), the current path will be cleared from the cairo context. See cairo_set_line_width(), cairo_set_line_join(), cairo_set_line_cap(), cairo_set_dash(), and cairo_stroke_preserve().

Note: Degenerate segments and sub-paths are treated specially and provide a useful result. These can result in two different situations:

Zero-length \"on\" segments set in cairo_set_dash(). If the cap style is CAIRO_LINE_CAP_ROUND or CAIRO_LINE_CAP_SQUARE then these segments will be drawn as circular dots or squares respectively. In the case of CAIRO_LINE_CAP_SQUARE, the orientation of the squares is determined by the direction of the underlying path.

A sub-path created by cairo_move_to() followed by either a cairo_close_path() or one or more calls to cairo_line_to() to the same coordinate as the cairo_move_to(). If the cap style is CAIRO_LINE_CAP_ROUND then these sub-paths will be drawn as circular dots. Note that in the case of CAIRO_LINE_CAP_SQUARE a degenerate sub-path will not be drawn at all, (since the correct orientation is indeterminate).

In no case will a cap style of CAIRO_LINE_CAP_BUTT cause anything to be drawn in the case of either degenerate segments or sub-paths.

Parameters
cr

a cairo context

 
Since: 1.0

"
(lowlevel-cairo-stroke cr))

(define lowlevel-cairo-stroke
  (foreign-library-function "libcairo" "cairo_stroke"
                            #:return-type void
                            #:arg-types (list '*)))


(define (cairo-arc cr xc yc radius angle1 angle2)
  "cairo_arc ()
void
cairo_arc (cairo_t *cr,
           double xc,
           double yc,
           double radius,
           double angle1,
           double angle2);
Adds a circular arc of the given radius to the current path. The arc is centered at (xc , yc ), begins at angle1 and proceeds in the direction of increasing angles to end at angle2 . If angle2 is less than angle1 it will be progressively increased by 2*M_PI until it is greater than angle1 .

If there is a current point, an initial line segment will be added to the path to connect the current point to the beginning of the arc. If this initial line is undesired, it can be avoided by calling cairo_new_sub_path() before calling cairo_arc().

Angles are measured in radians. An angle of 0.0 is in the direction of the positive X axis (in user space). An angle of M_PI/2.0 radians (90 degrees) is in the direction of the positive Y axis (in user space). Angles increase in the direction from the positive X axis toward the positive Y axis. So with the default transformation matrix, angles increase in a clockwise direction.

(To convert from degrees to radians, use degrees * (M_PI / 180.).)

This function gives the arc in the direction of increasing angles; see cairo_arc_negative() to get the arc in the direction of decreasing angles.

The arc is circular in user space. To achieve an elliptical arc, you can scale the current transformation matrix by different amounts in the X and Y directions. For example, to draw an ellipse in the box given by x , y , width , height :

1
2
3
4
5
cairo_save (cr);
cairo_translate (cr, x + width / 2., y + height / 2.);
cairo_scale (cr, width / 2., height / 2.);
cairo_arc (cr, 0., 0., 1., 0., 2 * M_PI);
cairo_restore (cr);
Parameters
cr

a cairo context

 
xc

X position of the center of the arc

 
yc

Y position of the center of the arc

 
radius

the radius of the arc

 
angle1

the start angle, in radians

 
angle2

the end angle, in radians

 
Since: 1.0

"
  (lowlevel-cairo-arc cr xc yc radius angle1 angle2))

;;lowlevel-cairo-arc cr xc yc radius angle1 angle2
(define lowlevel-cairo-arc
  (foreign-library-function "libcairo" "cairo_arc"
                            #:return-type void
                            #:arg-types (list '*
					      double
					      double
					      double
					      double
					      double)))

(define (cairo-line-to cr x y)
  "cairo_line_to ()
void
cairo_line_to (cairo_t *cr,
               double x,
               double y);
Adds a line to the path from the current point to position (x , y ) in user-space coordinates. After this call the current point will be (x , y ).

If there is no current point before the call to cairo_line_to() this function will behave as cairo_move_to(cr , x , y ).

Parameters
cr

a cairo context

 
x

the X coordinate of the end of the new line

 
y

the Y coordinate of the end of the new line

 
Since: 1.0"
  (lowlevel-cairo-line-to cr x y))

(define lowlevel-cairo-line-to
  (foreign-library-function "libcairo" "cairo_line_to"
                            #:return-type void
                            #:arg-types (list '* double double)))



(define (cairo-surface-flush surface)
  "cairo_surface_flush ()
void
cairo_surface_flush (cairo_surface_t *surface);
Do any pending drawing for the surface and also restore any temporary modifications cairo has made to the surface's state. This function must be called before switching from drawing on the surface with cairo to drawing on it directly with native APIs, or accessing its memory outside of Cairo. If the surface doesn't support direct access, then this function does nothing.

Parameters
surface

a cairo_surface_t

 
Since: 1.0"
  (lowlevel-cairo-surface-flush surface))

;;void cairo_surface_flush (cairo_surface_t *surface);
(define lowlevel-cairo-surface-flush
  (foreign-library-function "libcairo" "cairo_surface_flush"
                            #:return-type void
                            #:arg-types (list '*)))

(define (cairo-destroy cr)
  "cairo_destroy ()
void cairo_destroy (cairo_t *cr);
Decreases the reference count on cr by one. If the result is zero, then cr and all associated resources are freed. See cairo_reference().

Parameters
cr

a cairo_t

 
Since: 1.0"
  (lowlevel-cairo-destroy cr))

(define lowlevel-cairo-destroy
  (foreign-library-function "libcairo" "cairo_destroy"
                            #:return-type void
                            #:arg-types (list '*)))



;; we need convert c char* to scheme string
;; (pointer->string ..)
(define (cairo-version-string)
  "const char * cairo_version_string (void);
Returns the version of the cairo library as a human-readable string of the form \"X.Y.Z\".

See also cairo_version() as well as the compile-time equivalents CAIRO_VERSION_STRING and CAIRO_VERSION.

Returns
a string containing the version.
Since: 1.0"
  (pointer->string
   (lowlevel-cairo-version-string)))


(define lowlevel-cairo-version-string
  (foreign-library-function "libcairo" "cairo_version_string"
                            #:return-type '*
                            #:arg-types (list)))



;; int SDL_PollEvent(SDL_Event * event);
(define sdl-poll-event
  (foreign-library-function "libSDL2" "SDL_PollEvent"
			    #:return-type int
                            #:arg-types (list '*)))

(define *sdl-quit* #x100)
(define *sdl-keydown* #x300)
(define *sdl-keyup* #x301)
(define *sdl-mousemotion* #x400)
(define *sdl-window-event* #x200)

(define *sdl-scancode-unknown* 0) 
(define *sdl-scancode-a* 4) 
(define *sdl-scancode-b* 5) 
(define *sdl-scancode-c* 6) 
(define *sdl-scancode-d* 7) 
(define *sdl-scancode-e* 8) 
(define *sdl-scancode-f* 9) 
(define *sdl-scancode-g* 10) 
(define *sdl-scancode-h* 11) 
(define *sdl-scancode-i* 12) 
(define *sdl-scancode-j* 13) 
(define *sdl-scancode-k* 14) 
(define *sdl-scancode-l* 15) 
(define *sdl-scancode-m* 16) 
(define *sdl-scancode-n* 17) 
(define *sdl-scancode-o* 18) 
(define *sdl-scancode-p* 19) 
(define *sdl-scancode-q* 20) 
(define *sdl-scancode-r* 21) 
(define *sdl-scancode-s* 22) 
(define *sdl-scancode-t* 23) 
(define *sdl-scancode-u* 24) 
(define *sdl-scancode-v* 25) 
(define *sdl-scancode-w* 26) 
(define *sdl-scancode-x* 27) 
(define *sdl-scancode-y* 28) 
(define *sdl-scancode-z* 29) 
(define *sdl-scancode-1* 30) 
(define *sdl-scancode-2* 31) 
(define *sdl-scancode-3* 32) 
(define *sdl-scancode-4* 33) 
(define *sdl-scancode-5* 34) 
(define *sdl-scancode-6* 35) 
(define *sdl-scancode-7* 36) 
(define *sdl-scancode-8* 37) 
(define *sdl-scancode-9* 38) 
(define *sdl-scancode-0* 39) 
(define *sdl-scancode-return* 40) 
(define *sdl-scancode-escape* 41) 
(define *sdl-scancode-backspace* 42) 
(define *sdl-scancode-tab* 43) 
(define *sdl-scancode-space* 44) 
(define *sdl-scancode-minus* 45) 
(define *sdl-scancode-equals* 46) 
(define *sdl-scancode-leftbracket* 47) 
(define *sdl-scancode-rightbracket* 48) 
(define *sdl-scancode-backslash* 49) 
(define *sdl-scancode-nonushash* 50) 
(define *sdl-scancode-semicolon* 51) 
(define *sdl-scancode-apostrophe* 52) 
(define *sdl-scancode-grave* 53) 
(define *sdl-scancode-comma* 54) 
(define *sdl-scancode-period* 55) 
(define *sdl-scancode-slash* 56) 
(define *sdl-scancode-capslock* 57) 
(define *sdl-scancode-f1* 58) 
(define *sdl-scancode-f2* 59) 
(define *sdl-scancode-f3* 60) 
(define *sdl-scancode-f4* 61) 
(define *sdl-scancode-f5* 62) 
(define *sdl-scancode-f6* 63) 
(define *sdl-scancode-f7* 64) 
(define *sdl-scancode-f8* 65) 
(define *sdl-scancode-f9* 66) 
(define *sdl-scancode-f10* 67) 
(define *sdl-scancode-f11* 68) 
(define *sdl-scancode-f12* 69) 
(define *sdl-scancode-printscreen* 70) 
(define *sdl-scancode-scrolllock* 71) 
(define *sdl-scancode-pause* 72) 
(define *sdl-scancode-insert* 73) 
(define *sdl-scancode-home* 74) 
(define *sdl-scancode-pageup* 75) 
(define *sdl-scancode-delete* 76) 
(define *sdl-scancode-end* 77) 
(define *sdl-scancode-pagedown* 78) 
(define *sdl-scancode-right* 79) 
(define *sdl-scancode-left* 80) 
(define *sdl-scancode-down* 81) 
(define *sdl-scancode-up* 82) 
(define *sdl-scancode-numlockclear* 83) 
(define *sdl-scancode-kp-divide* 84) 
(define *sdl-scancode-kp-multiply* 85) 
(define *sdl-scancode-kp-minus* 86) 
(define *sdl-scancode-kp-plus* 87) 
(define *sdl-scancode-kp-enter* 88) 
(define *sdl-scancode-kp-1* 89) 
(define *sdl-scancode-kp-2* 90) 
(define *sdl-scancode-kp-3* 91) 
(define *sdl-scancode-kp-4* 92) 
(define *sdl-scancode-kp-5* 93) 
(define *sdl-scancode-kp-6* 94) 
(define *sdl-scancode-kp-7* 95) 
(define *sdl-scancode-kp-8* 96) 
(define *sdl-scancode-kp-9* 97) 
(define *sdl-scancode-kp-0* 98) 
(define *sdl-scancode-kp-period* 99) 
(define *sdl-scancode-nonusbackslash* 100) 
(define *sdl-scancode-application* 101) 
(define *sdl-scancode-power* 102) 
(define *sdl-scancode-kp-equals* 103) 
(define *sdl-scancode-f13* 104) 
(define *sdl-scancode-f14* 105) 
(define *sdl-scancode-f15* 106) 
(define *sdl-scancode-f16* 107) 
(define *sdl-scancode-f17* 108) 
(define *sdl-scancode-f18* 109) 
(define *sdl-scancode-f19* 110) 
(define *sdl-scancode-f20* 111) 
(define *sdl-scancode-f21* 112) 
(define *sdl-scancode-f22* 113) 
(define *sdl-scancode-f23* 114) 
(define *sdl-scancode-f24* 115) 
(define *sdl-scancode-execute* 116) 
(define *sdl-scancode-help* 117) 
(define *sdl-scancode-menu* 118) 
(define *sdl-scancode-select* 119) 
(define *sdl-scancode-stop* 120) 
(define *sdl-scancode-again* 121) 
(define *sdl-scancode-undo* 122) 
(define *sdl-scancode-cut* 123) 
(define *sdl-scancode-copy* 124) 
(define *sdl-scancode-paste* 125) 
(define *sdl-scancode-find* 126) 
(define *sdl-scancode-mute* 127) 
(define *sdl-scancode-volumeup* 128) 
(define *sdl-scancode-volumedown* 129) 
(define *sdl-scancode-lockingcapslock* 130) 
(define *sdl-scancode-lockingnumlock* 131) 
(define *sdl-scancode-lockingscrolllock* 132) 
(define *sdl-scancode-kp-comma* 133) 
(define *sdl-scancode-kp-equalsas400* 134) 
(define *sdl-scancode-international1* 135) 
(define *sdl-scancode-international2* 136) 
(define *sdl-scancode-international3* 137) 
(define *sdl-scancode-international4* 138) 
(define *sdl-scancode-international5* 139) 
(define *sdl-scancode-international6* 140) 
(define *sdl-scancode-international7* 141) 
(define *sdl-scancode-international8* 142) 
(define *sdl-scancode-international9* 143) 
(define *sdl-scancode-lang1* 144) 
(define *sdl-scancode-lang2* 145) 
(define *sdl-scancode-lang3* 146) 
(define *sdl-scancode-lang4* 147) 
(define *sdl-scancode-lang5* 148) 
(define *sdl-scancode-lang6* 149) 
(define *sdl-scancode-lang7* 150) 
(define *sdl-scancode-lang8* 151) 
(define *sdl-scancode-lang9* 152) 
(define *sdl-scancode-alterase* 153) 
(define *sdl-scancode-sysreq* 154) 
(define *sdl-scancode-cancel* 155) 
(define *sdl-scancode-clear* 156) 
(define *sdl-scancode-prior* 157) 
(define *sdl-scancode-return2* 158) 
(define *sdl-scancode-separator* 159) 
(define *sdl-scancode-out* 160) 
(define *sdl-scancode-oper* 161) 
(define *sdl-scancode-clearagain* 162) 
(define *sdl-scancode-crsel* 163) 
(define *sdl-scancode-exsel* 164) 
(define *sdl-scancode-kp-00* 176) 
(define *sdl-scancode-kp-000* 177) 
(define *sdl-scancode-thousandsseparator* 178) 
(define *sdl-scancode-decimalseparator* 179) 
(define *sdl-scancode-currencyunit* 180) 
(define *sdl-scancode-currencysubunit* 181) 
(define *sdl-scancode-kp-leftparen* 182) 
(define *sdl-scancode-kp-rightparen* 183) 
(define *sdl-scancode-kp-leftbrace* 184) 
(define *sdl-scancode-kp-rightbrace* 185) 
(define *sdl-scancode-kp-tab* 186) 
(define *sdl-scancode-kp-backspace* 187) 
(define *sdl-scancode-kp-a* 188) 
(define *sdl-scancode-kp-b* 189) 
(define *sdl-scancode-kp-c* 190) 
(define *sdl-scancode-kp-d* 191) 
(define *sdl-scancode-kp-e* 192) 
(define *sdl-scancode-kp-f* 193) 
(define *sdl-scancode-kp-xor* 194) 
(define *sdl-scancode-kp-power* 195) 
(define *sdl-scancode-kp-percent* 196) 
(define *sdl-scancode-kp-less* 197) 
(define *sdl-scancode-kp-greater* 198) 
(define *sdl-scancode-kp-ampersand* 199) 
(define *sdl-scancode-kp-dblampersand* 200) 
(define *sdl-scancode-kp-verticalbar* 201) 
(define *sdl-scancode-kp-dblverticalbar* 202) 
(define *sdl-scancode-kp-colon* 203) 
(define *sdl-scancode-kp-hash* 204) 
(define *sdl-scancode-kp-space* 205) 
(define *sdl-scancode-kp-at* 206) 
(define *sdl-scancode-kp-exclam* 207) 
(define *sdl-scancode-kp-memstore* 208) 
(define *sdl-scancode-kp-memrecall* 209) 
(define *sdl-scancode-kp-memclear* 210) 
(define *sdl-scancode-kp-memadd* 211) 
(define *sdl-scancode-kp-memsubtract* 212) 
(define *sdl-scancode-kp-memmultiply* 213) 
(define *sdl-scancode-kp-memdivide* 214) 
(define *sdl-scancode-kp-plusminus* 215) 
(define *sdl-scancode-kp-clear* 216) 
(define *sdl-scancode-kp-clearentry* 217) 
(define *sdl-scancode-kp-binary* 218) 
(define *sdl-scancode-kp-octal* 219) 
(define *sdl-scancode-kp-decimal* 220) 
(define *sdl-scancode-kp-hexadecimal* 221) 
(define *sdl-scancode-lctrl* 224) 
(define *sdl-scancode-lshift* 225) 
(define *sdl-scancode-lalt* 226) 
(define *sdl-scancode-lgui* 227) 
(define *sdl-scancode-rctrl* 228) 
(define *sdl-scancode-rshift* 229) 
(define *sdl-scancode-ralt* 230) 
(define *sdl-scancode-rgui* 231) 
(define *sdl-scancode-mode* 257) 
(define *sdl-scancode-audionext* 258) 
(define *sdl-scancode-audioprev* 259) 
(define *sdl-scancode-audiostop* 260) 
(define *sdl-scancode-audioplay* 261) 
(define *sdl-scancode-audiomute* 262) 
(define *sdl-scancode-mediaselect* 263) 
(define *sdl-scancode-www* 264) 
(define *sdl-scancode-mail* 265) 
(define *sdl-scancode-calculator* 266) 
(define *sdl-scancode-computer* 267) 
(define *sdl-scancode-ac-search* 268) 
(define *sdl-scancode-ac-home* 269) 
(define *sdl-scancode-ac-back* 270) 
(define *sdl-scancode-ac-forward* 271) 
(define *sdl-scancode-ac-stop* 272) 
(define *sdl-scancode-ac-refresh* 273) 
(define *sdl-scancode-ac-bookmarks* 274) 
(define *sdl-scancode-brightnessdown* 275) 
(define *sdl-scancode-brightnessup* 276) 
(define *sdl-scancode-displayswitch* 277) 
(define *sdl-scancode-kbdillumtoggle* 278) 
(define *sdl-scancode-kbdillumdown* 279) 
(define *sdl-scancode-kbdillumup* 280) 
(define *sdl-scancode-eject* 281) 
(define *sdl-scancode-sleep* 282) 
(define *sdl-scancode-app1* 283) 
(define *sdl-scancode-app2* 284) 
(define *sdl-scancode-audiorewind* 285) 
(define *sdl-scancode-audiofastforward* 286) 
(define *sdl-scancode-softleft* 287) 
(define *sdl-scancode-softright* 288) 
(define *sdl-scancode-call* 289) 
(define *sdl-scancode-endcall* 290) 
(define *sdl-num-scancodes* 512)

(define *sdl-window-event-none* 0)
(define *sdl-window-event-shown* 1)
(define *sdl-window-event-hidden* 2)
(define *sdl-window-event-exposed* 3)
(define *sdl-window-event-moved* 4)
(define *sdl-window-event-resized* 5)
(define *sdl-window-event-changed* 6)
(define *sdl-window-event-minimized* 7)
(define *sdl-window-event-maximized* 8)
(define *sdl-window-event-restored* 9)
(define *sdl-window-event-enter* 10)
(define *sdl-window-event-leave* 11)
(define *sdl-window-event-focus-gained* 12)
(define *sdl-window-event-focus-lost* 13)
(define *sdl-window-event-close* 14)
(define *sdl-window-event-take-focus* 15)
(define *sdl-window-event-hit-test* 16)
(define *sdl-window-event-icc-prof-changed* 17)
(define *sdl-window-event-display-changed* 18)

;;(define show-pixelformat (foreign-library-pointer "pixelformat" "show_pixelformat_format"))
;;(define init-pixelformat (foreign-library-pointer "pixelformat" "init_pixelformat"))

(define sanity-check-hack
  (foreign-library-function "libpixelformat" "sanity_check_hack"
                            #:return-type void
                            #:arg-types (list '* '* '*)))
  


(define pixelformat2
  (foreign-library-function "libpixelformat" "pixelformat2"
                            #:return-type void
                            #:arg-types (list '*)))

(define output-check
  (foreign-library-function "libpixelformat" "output_check"
                            #:return-type void
                            #:arg-types (list)))


(define applyStretchedImage
  (foreign-library-function "libpixelformat" "applyStretchedImage"
                            #:return-type '*
                            #:arg-types (list '* int int)))


(define size-int
  (foreign-library-function "libpixelformat" "size_int"
                            #:return-type int
                            #:arg-types (list)))




;; int SDL_UpperBlitScaled
;;   (SDL_Surface * src, const SDL_Rect * srcrect,
;;   SDL_Surface * dst, SDL_Rect * dstrect);
(define sdl-upper-blit-scaled
  (foreign-library-function "libSDL2" "SDL_UpperBlitScaled"
                            #:return-type int
                            #:arg-types (list '* '* '* '*)))
  


#|
;; (define sdl-upper-blit-scaled
;;   (foreign-library-function "libSDL2_image-2.0" "SDL_IMAGE2_C_FUNCTION_HERE"
;;                             #:return-type int
;;                             #:arg-types (list '* '* '* '*)))
typedef enum IMG_InitFlags
{
    IMG_INIT_JPG    = 0x00000001,
    IMG_INIT_PNG    = 0x00000002,
    IMG_INIT_TIF    = 0x00000004,
    IMG_INIT_WEBP   = 0x00000008,
    IMG_INIT_JXL    = 0x00000010,
    IMG_INIT_AVIF   = 0x00000020
    } IMG_InitFlags;
|#

(define *sdl-image-init-jpg*  #x00000001)
(define *sdl-image-init-png*  #x00000002)
(define *sdl-image-init-tif*  #x00000004)
(define *sdl-image-init-webp* #x00000008)
(define *sdl-image-init-jxl*  #x00000010)
(define *sdl-image-init-avif* #x00000020)


;;int IMG_Init(int flags);
(define %img-init
  (foreign-library-function "libSDL2_image" "IMG_Init"
                            #:return-type int
                            #:arg-types (list int)))


(define (image-init)
  (let* ((flags (logior *sdl-image-init-jpg*
			*sdl-image-init-png*
			*sdl-image-init-tif*
			*sdl-image-init-webp*
			;;*sdl-image-init-jxl*
			;;*sdl-image-init-avif*
			))
	 (result (%img-init flags)))
    (= result flags)))

;;SDL_Surface * IMG_Load(const char *file);
(define %img-load
  (foreign-library-function "libSDL2_image" "IMG_Load"
                            #:return-type '*
                            #:arg-types (list '*)))

;; convert guile string to char* 
(define (image-load path)
  (%img-load (string->pointer path)))

 
;; (define sdl-upper-blit-scaled
;;   (foreign-library-function "libSDL2_ttf" "TTF-C-FUNCTION-HERE"
;;                             #:return-type int
;;                             #:arg-types (list '* '* '* '*)))

;; (define sdl-upper-blit-scaled
;;   (foreign-library-function "libSDL2_mixer" "MIXER-C-FUNCTION-HERE"
;;                             #:return-type int
;;                             #:arg-types (list '* '* '* '*)))


;; SDL_Renderer * SDL_CreateRenderer(SDL_Window * window,
;;                        int index, Uint32 flags);
(define %sdl-create-renderer
  (foreign-library-function "libSDL2" "SDL_CreateRenderer"
                            #:return-type '*
                            #:arg-types (list '* int uint32)))


;; uint32_t surface_pixelformat_format(SDL_Surface *s);
(define surface-pixelformat-format
  (foreign-library-function "libpixelformat" "surface_pixelformat_format"
                            #:return-type uint32
                            #:arg-types (list '*)))


(define surface-pixelformat
  (foreign-library-function "libpixelformat" "surface_pixelformat"
                            #:return-type '*
                            #:arg-types (list '*)))


;; unsigned char * surface_pixels(SDL_Surface *s)
;; "void * surface_pixels(SDL_Surface *s)"  
(define surface-pixels
  (foreign-library-function "libpixelformat" "surface_pixels"
                            #:return-type '*
                            #:arg-types (list '*)))

;;"int surface_pixels(SDL_Surface *s)"
(define surface-pitch
  (foreign-library-function "libpixelformat" "surface_pitch"
                            #:return-type int
                            #:arg-types (list '*)))

;; int surface_width(SDL_Surface *s)
(define surface-width
  (foreign-library-function "libpixelformat" "surface_width"
                            #:return-type int
                            #:arg-types (list '*)))

;;int surface_height(SDL_Surface *s)
(define surface-height
  (foreign-library-function "libpixelformat" "surface_height"
                            #:return-type int
                            #:arg-types (list '*)))

;;const char* SDL_GetPixelFormatName(Uint32 format);
(define sdl-get-pixelformat-name
  (foreign-library-function "libSDL2" "SDL_GetPixelFormatName"
                            #:return-type '*
                            #:arg-types (list uint32)))


;; int SDL_LockSurface(SDL_Surface * surface);
(define sdl-lock-surface 
  (foreign-library-function "libSDL2" "SDL_LockSurface"
                            #:return-type int
                            #:arg-types (list '*)))

(define sdl-unlock-surface 
  (foreign-library-function "libSDL2" "SDL_UnlockSurface"
                            #:return-type void
                            #:arg-types (list '*)))



;; SDL_SetRenderDrawColor
;; int SDL_SetRenderDrawColor(SDL_Renderer * renderer,
;;                    Uint8 r, Uint8 g, Uint8 b,
;;                    Uint8 a);
(define sdl-set-render-draw-color
  (foreign-library-function "libSDL2" "SDL_SetRenderDrawColor"
                            #:return-type int
                            #:arg-types (list '* uint8 uint8 uint8 uint8)))

(define show-rect
  (foreign-library-function "libpixelformat" "show_rect"
                            #:return-type void
                            #:arg-types (list '*)))



;; (define %load-texture
;;   (foreign-library-function "libpixelformat" "loadTexture"
;;                             #:return-type '*
;;                             #:arg-types (list '* '*)))
  
;; (define (load-texture s render)
;;   (%load-texture (string->pointer s) render))



#|
typedef enum SDL_RendererFlags
{
    SDL_RENDERER_SOFTWARE = 0x00000001,         /**< The renderer is a software fallback */
    SDL_RENDERER_ACCELERATED = 0x00000002,      /**< The renderer uses hardware
                                                     acceleration */
    SDL_RENDERER_PRESENTVSYNC = 0x00000004,     /**< Present is synchronized
                                                     with the refresh rate */
    SDL_RENDERER_TARGETTEXTURE = 0x00000008     /**< The renderer supports
                                                     rendering to texture */
} SDL_RendererFlags;
|#

(define *sdl-renderer-software* #x00000001)
(define *sdl-renderer-accelerated* #x00000002)
(define *sdl-renderer-present-vsync* #x00000004)
(define *sdl-renderer-target-texture* #x00000008)

;; if %null-pointer create renderer failed
(define (create-renderer window)
  "create-renderer window"
  (%sdl-create-renderer window -1 (logior *sdl-renderer-accelerated*
					  *sdl-renderer-target-texture*)))


(define dummy 0)






