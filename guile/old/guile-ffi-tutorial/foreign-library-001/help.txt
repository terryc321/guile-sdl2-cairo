
Guile

(%site-dir) => /opt/guile/share/guile/site/3.0

sudo mkdir -pv /opt/guile/share/guile/site/3.0
sudo mkdir -pv /opt/guile/share/guile/site/3.0/macros
sudo cp -v fcase.scm /opt/guile/share/guile/site/3.0/macros
sudo cp -v inc.scm /opt/guile/share/guile/site/3.0/macros

> guile
(use-modules (macros fcase))
(use-modules (macros inc))

(let ((x 1))(inc! x) x) => 2

indeed any useful macro we write from now on in guile will be created and can then be placed into the macros module

this will allow us to tailor the scheme language to an exact precise fit we desire !

lets also create the cache directory for compiled .go files

(%site-ccache-dir) => /opt/guile/lib/guile/3.0/site-ccache
sudo mkdir -pv /opt/guile/lib/guile/3.0/site-ccache


## dynamically loadable libraries

pixelformat/libpixelformat.so is a shared library created to help with sdl2-image library

create dynamic extension directory for guile

> sudo mkdir -pv /usr/local/lib/guile/3.0/extensions/

then copy the libpixelformat.so to that directory

> sudo cp -v pixelformat/libpixelformat.so /usr/local/lib/guile/3.0/extensions/

we should now be able to reference libpixelformat without having to change LTDL_LIBRARY_PATH etc... at startup.sh

ACTUALLY our extensions directory is

/opt/guile/lib/guile/3.0/extensions

> sudo cp -v pixelformat/libpixelformat.so /opt/guile/lib/guile/3.0/extensions

> guile
> (load "test.scm")
> (skooldaze2)

SORTED ! ALL GRAPHICS UP AND RUNNING !


6 API Reference
Guile provides an application programming interface (API ) to developers in two core lan-
guages: Scheme and C. This part of the manual contains reference documentation for all of
the functionality that is available through both Scheme and C interfaces.

6.1 Overview of the Guile API
Guile’s application programming interface (API ) makes functionality available that an ap-
plication developer can use in either C or Scheme programming. The interface consists of
elements that may be macros, functions or variables in C, and procedures, variables, syntax
or other types of object in Scheme.

Many elements are available to both Scheme and C, in a form that is appropriate.
For example, the assq Scheme procedure is also available as scm_assq to C code. These
elements are documented only once, addressing both the Scheme and C aspects of them.
The Scheme name of an element is related to its C name in a regular way. Also, a C
function takes its parameters in a systematic way.
Normally, the name of a C function can be derived given its Scheme name, using some
simple textual transformations:
• Replace - (hyphen) with _ (underscore).
• Replace ? (question mark) with _p.
• Replace ! (exclamation point) with _x.
• Replace internal -> with _to_.
• Replace <= (less than or equal) with _leq.
• Replace >= (greater than or equal) with _geq.
• Replace < (less than) with _less.
• Replace > (greater than) with _gr.
• Prefix with scm_.
A C function always takes a fixed number of arguments of type SCM, even when the
corresponding Scheme function takes a variable number.
For some Scheme functions, some last arguments are optional; the corresponding C
function must always be invoked with all optional arguments specified. To get the effect
as if an argument has not been specified, pass SCM_UNDEFINED as its value. You can not
do this for an argument in the middle; when one argument is SCM_UNDEFINED all the ones
following it must be SCM_UNDEFINED as well.
Some Scheme functions take an arbitrary number of rest arguments; the corresponding
C function must be invoked with a list of all these arguments. This list is always the last
argument of the C function.
These two variants can also be combined.
The type of the return value of a C function that corresponds to a Scheme function is
always SCM. In the descriptions below, types are therefore often omitted but for the return
value and for the arguments.


Guile macro expansion

(a.k.a how to cope if you see tree-il code and expect a scheme s expression as output)




6.8.9 Macro Expansion
Usually, macros are expanded on behalf of the user as needed. Macro expansion is an integral part of eval and compile. Users can also expand macros at the REPL prompt via the expand REPL command; See Compile Commands.

Macros can also be expanded programmatically, via macroexpand, but the details get a bit hairy for two reasons.

The first complication is that the result of macro-expansion isn’t Scheme: it’s Tree-IL, Guile’s high-level intermediate language. See Tree-IL. As “hygienic macros” can produce identifiers that are distinct but have the same name, the output format needs to be able to represent distinctions between variable identities and names. Again, See Tree-IL, for all the details. The easiest thing is to just run tree-il->scheme on the result of macro-expansion:

(macroexpand '(+ 1 2))
⇒
#<tree-il (call (toplevel +) (const 1) (const 2))>

(use-modules (language tree-il))
(tree-il->scheme (macroexpand '(+ 1 2)))
⇒
(+ 1 2)
The second complication involves eval-when. As an example, what would it mean to macro-expand the definition of a macro?

(macroexpand '(define-syntax qux (identifier-syntax 'bar)))
⇒
?
The answer is that it depends who is macro-expanding, and why. Do you define the macro in the current environment? Residualize a macro definition? Both? Neither? The default is to expand in “eval” mode, which means an eval-when clauses will only proceed when eval (or expand) is in its condition set. Top-level macros will be eval’d in the top-level environment.

In this way (macroexpand foo) is equivalent to (macroexpand foo 'e '(eval)). The second argument is the mode ('e for “eval”) and the third is the eval-syntax-expanders-when parameter (only eval in this default setting).

But if you are compiling the macro definition, probably you want to reify the macro definition itself. In that case you pass 'c as the second argument to macroexpand. But probably you want the macro definition to be present at compile time as well, so you pass '(compile load eval) as the esew parameter. In fact (compile foo #:to 'tree-il) is entirely equivalent to (macroexpand foo 'c '(compile load eval)); See The Scheme Compiler.

It’s a terrible interface; we know. The macroexpander is somewhat tricky regarding modes, so unless you are building a macro-expanding tool, we suggest to avoid invoking it directly.



