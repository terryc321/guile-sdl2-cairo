(uiop:define-package :myproject
  (:use #:cl #:autowrap))

(in-package :myproject)

(cl:defun rel-path (path)
  (cl:format cl:nil "~a" (cl:merge-pathnames path (uiop:getcwd))))

#+(or)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (cffi-sys:%load-foreign-library
   :libtest (merge-pathnames "libtest.so" (asdf-path 'myproject))))

#+(or)
(autowrap:c-include (rel-path "./spec/test.h")
                    :spec-path "./spec/")

;; #+(or)
;; (c-include "test.h" ;;(merge-pathnames #P"spec/test.h" (asdf-path 'myproject))
;;            :spec-path (merge-pathnames #P"spec" (asdf-path 'myproject)))


#+(or)
(let ((foo (get-foo)))
  (:say foo)
  (:say (foo-t.a foo))
  (:say (foo-t.x[].a foo 0))
  (:say (foo-t.x[].f foo 1))
  (:say (foo-t.x[].b0 foo 0))
  (:say (foo-t.x[].b1 foo 0))
  (:say (cffi-sys:%mem-ref (ptr foo) :unsigned-char (+ 16 24)))
  (setf (foo-t.x[].b0 foo 0) #b01)
  (setf (foo-t.x[].b1 foo 0) #b110)
  (print-bits foo)
  (free-foo foo))


#+(or)
(let ((foo (get-foo)))
  (setf (foo-t.a foo) 5)             ;; foo.a = 5;
  (setf (foo-t.x[].b0 foo 0) #b10)   ;; foo.x[0].b0 = 2;
  (print (foo-t.x[].s.x foo 1))      ;; anonymous struct
  (foo-t.x[].s foo 0)                ;; => child wrapper
  (foo-t.x[].s& foo 0)               ;; &(foo.x[0].s) => pointer
  (free-foo foo))

(defvar foo (get-foo))
(setf (foo-t.a foo) 5)
(setf (foo-t.x[].b0 foo 0) #b10)   ;; foo.x[0].b0 = 2;
(print (foo-t.x[].s.x foo 1))      ;; anonymous struct
(foo-t.x[].s foo 0)                ;; => child wrapper

